// GENERATED by @edgedb/generate v0.4.1

import * as $ from "../../reflection";
import * as _ from "../../imports";
import type * as _std from "../std";
export declare type $Base64Alphabet = {
  "standard": $.$expr_Literal<$Base64Alphabet>;
  "urlsafe": $.$expr_Literal<$Base64Alphabet>;
} & $.EnumType<"std::enc::Base64Alphabet", ["standard", "urlsafe"]>;
declare const Base64Alphabet: $Base64Alphabet

declare type base64_encodeλFuncExpr<
  NamedArgs extends {
    "alphabet"?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>,
    "padding"?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>,
  },
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>,
> = $.$expr_Function<
  _std.$str, $.cardutil.multiplyCardinalities<$.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.optionalParamCardinality<NamedArgs["alphabet"]>>, $.cardutil.optionalParamCardinality<NamedArgs["padding"]>>
>;
declare type base64_encodeλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>,
> = $.$expr_Function<
  _std.$str, $.cardutil.paramCardinality<P1>
>;
/**
 * Encode given data as a base64 string
 */
declare function base64_encode<
  NamedArgs extends {
    "alphabet"?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>,
    "padding"?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>,
  },
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>,
>(
  namedArgs: NamedArgs,
  data: P1,
): base64_encodeλFuncExpr<NamedArgs, P1>;
/**
 * Encode given data as a base64 string
 */
declare function base64_encode<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>,
>(
  data: P1,
): base64_encodeλFuncExpr2<P1>;

declare type base64_decodeλFuncExpr<
  NamedArgs extends {
    "alphabet"?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>,
    "padding"?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>,
  },
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>,
> = $.$expr_Function<
  _std.$bytes, $.cardutil.multiplyCardinalities<$.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.optionalParamCardinality<NamedArgs["alphabet"]>>, $.cardutil.optionalParamCardinality<NamedArgs["padding"]>>
>;
declare type base64_decodeλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>,
> = $.$expr_Function<
  _std.$bytes, $.cardutil.paramCardinality<P1>
>;
/**
 * Decode the byte64-encoded byte string and return decoded bytes.
 */
declare function base64_decode<
  NamedArgs extends {
    "alphabet"?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>,
    "padding"?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>,
  },
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>,
>(
  namedArgs: NamedArgs,
  data: P1,
): base64_decodeλFuncExpr<NamedArgs, P1>;
/**
 * Decode the byte64-encoded byte string and return decoded bytes.
 */
declare function base64_decode<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>,
>(
  data: P1,
): base64_decodeλFuncExpr2<P1>;



export { Base64Alphabet };

declare type __defaultExports = {
  "Base64Alphabet": typeof Base64Alphabet;
  "base64_encode": typeof base64_encode;
  "base64_decode": typeof base64_decode
};
declare const __defaultExports: __defaultExports;
export default __defaultExports;
